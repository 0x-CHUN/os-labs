# chun-os
lab 1
===
Answers：
1. 计算机上电，BIOS初始化中断向量表后，会将启动设备的第一个扇区（即引导扇区）读入内存地址0x7c00（31KB)处，并跳转到此处开始执行。而为了方便加载主模块，引导程序首先会将自己移动到内存相对靠后的位置，如linux0.11的bootsect程序先将自己移动到0x90000(576KB)处。这样先移动是多此一举的。
    解决方案：在保证可靠性的前提下尽量扩大实地址模式下BIOS可访问的内存的范围，如引导扇区加载到0x90000等内存高地址处而不是0x7c00。
 
2. 计算机上电后，ROM BIOS会在物理内存0处初始化中断向量表，其中有256个中断向量，每个中断向量占用4字节，共1KB，在物理内存地址0x000 - ox3ff处，这些中断向量供BIOS中断使用。这就导致了一个问题，如果操作系统的引导程序在加载操作系统时使用了BIOS中断来获取或者显示一些信息时，这1KB地址不能被覆盖。然而操作系统的主模块为了让其中代码地址等于实际的物理地址，需要将其加载到内存0x0000处。所以操作系统在加载时需要先将主模块加载到内存中不与BIOS中断向量表冲突的地方，之后可以覆盖中断向量表时才将其移动到内存起始处，如Linux0.11的System模块就是在bootsect程序中先加载到0x10000,之后在setup程序中移到0x0000处。 这样先加载到另外地方之后再移动到内存起始位置是多此一举的。
    解决方案：可以将BIOS中断向量表放到实模式下能寻址内存的其他地方，操作系统引导程序直接将操作系统的主模块读到内存的起始处。
___
lab 2 
===
Answers:
1. 从linux-0.11/include/unistd.h中可以知道_syscall宏展开的系统调用最多3个参数，使用ebx，ecx，edx三个寄存器传递参数。
    解决限制的方法：将需要传递的多个参数保存在有特定结构的区间中，并将该用户态地址空间的这个区间的首地址作为一个参数传递给系统调用。最后通过寄存器间接寻址方式便可以访问所有参数。当然，这么做的话，参数合法性验证尤其必要。实际上，linux2.6内核废除了_syscall宏，而使用syscall函数，其接受一个可变参数，原理类似，参考《深入理解Linux内核（第三版）》 P409。

2.
    1. 修改 include/linux/sys.h 在sys_call_table数组最后加入sys_foo，并仿照上面给出其他系统调用格式加上
        ```c
        extern rettype sys_foo();
        ```
        修改include/unistd.h #define __NR_foo num num为接下来使用的系统调用号
    2. 然后修改 kernel/system_call.s  
        ```
            nr_system_calls = num
        ```
        num为在原值加1 即系统调用总数目加1
    3. 接着在kernel中添加 foo.c ,若需要支持内核态与用户态数据交互,则包含include/asm/segment.h，其中有put_fs_XXX  get_fs_XXX函数,在foo.c实现系统调用sys_foo()
    4. 最后修改kernel的Makefile，将foo.c与内核其它代码编译链接到一起系统调用用户界面要 
        ```c
        #define __LIBRARY__
        #include <unistd.h>
        ```
        _syscallN宏展开系统调用，提供用户态的系统调用接口（参数数目确定具体宏）



