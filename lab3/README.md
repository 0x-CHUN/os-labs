实验步骤
===
* 按照给定的模板写process.c，主要写main函数创建进程，然后在Linux-0.11上编译测试运行结果
* 在还没开始fork的时候，即进程0中进行log文件的打开，与文件描述符3相关联  --- init/main.c
   + 进程0和1的文件描述符肯定和log相关联
   + 理论上后面的进程都会继承1，但是后面会在/bin/sh重新初始化，所以只有0和1相关联
* 写log文件
   + 和printk功能类似，代码放在 kernel/printk.c
   + 代码给出
* 跟踪进程运动轨迹
   + 滴答
     - 维护全局变量jiffies --- 记录从开机到当前时间的时钟中断发生次数 kernel/sched.c
     - set_intr_gate(0x20,&timer_interrupt)  sched_init里面时间中断处理函数
     - incl jiffies            # 增加时钟中断发生次数的值---滴答数  kernel/system_call里    10ms产生一个滴答
   + 寻找状态切换点
     - sys_fork 实现了fork功能  kernel/system_call里
     - copy_process 真正意义上实现来进程的创建  kernel/fork.c里面
     - 在 copy_process 中输出新建+就绪 log
     - 记录睡眠 sleep_on() interruptible_sleep_on() kernel/sched.c
     - 一系列的记录Log
   + 编译取出Log分析
   + 修改时间片分析Log变化

运行截图
===
时间片：10  
！[](图片1.png)
时间片：15
！[](图片2.png)
时间片：20
！[](图片3.png)

Answer
===
1. 结合自己的体会，谈谈从程序设计者的角度看，单进程编程和多进程编程的最大区别是什么？

单进程的编程是按照所写程序的顺序所执行的，在程序与程序之前有着严格的逻辑先后顺序。

多进程编程是所有的程序是同时执行的，互相共享文件。但是由于多个进程之间的额执行顺序是无法得知的，所有要考略多个进程之间的相互影响。换句话说，在写程序的时候要考略到进程之间的同步，通信，互斥等。

多进程编程虽然比较复杂，但是用途更多广泛，有着很多单进程无法媲美的优点。

2. 你是如何修改时间片的？仅针对样本程序建立的进程，在修改时间片前后，log文件的统计结果都是怎么样的？结合你的修改分析一下为什么会这样变化？或者为什么没有变化

修改include/linux/sched.h里面的宏定义 INIT_TASK即可1.结合自己的体会，谈谈从程序设计者的角度看，单进程编程和多进程编程的最大区别是什么？

单进程的编程是按照所写程序的顺序所执行的，在程序与程序之前有着严格的逻辑先后顺序。

多进程编程是所有的程序是同时执行的，互相共享文件。但是由于多个进程之间的额执行顺序是无法得知的，所有要考略多个进程之间的相互影响。换句话说，在写程序的时候要考略到进程之间的同步，通信，互斥等。

多进程编程虽然比较复杂，但是用途更多广泛，有着很多单进程无法媲美的优点。

2.你是如何修改时间片的？仅针对样本程序建立的进程，在修改时间片前后，log文件的统计结果都是怎么样的？结合你的修改分析一下为什么会这样变化？或者为什么没有变化

修改include/linux/sched.h里面的宏定义 INIT_TASK即可